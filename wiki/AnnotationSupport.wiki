#summary Overview of the annotation support features of cqrs4j
#labels Featured
#sidebar TableOfContents

<wiki:toc max_depth="2" />

= Introduction =

We strongly believe in the POJO programming model. Furthermore, the goal of _cqrs4j_ is to relieve you of any plumbing and boilerplate coding. The annotation support features of _cqrs4j_ allow you to build plain event listeners (just extending object) and annotating the relevant event handling methods with `@EventHandler`.

= Annotation support for aggregates =

Annotation support is automatically available to all aggregates that extend `AbstractAnnotatedAggregateRoot`.

See [AnnotationSupport#Creating_an_annotated_event_handler Creating an annotated event handler] for information about the signature of annotated event handler methods.

Here is an example of a simple aggregate using annotation support:
{{{
public class Customer extends AbstractAnnotatedAggregateRoot {

    public Customer(Address address, String name) {
        apply(new NewCustomerEvent(address, name));
    }

    @EventHandler
    protected void onNewCustomer(NewCustomerEvent newCustomerEvent) {
        // do the state changes
    }
}
}}}
= Enabling annotation support =

To enable annotation support, all you need to do is configure one of the annotation post processors in your spring context.

There are two annotation post processors available:
# `AnnotationEventListenerBeanPostProcessor`, the simplest of the two, will automatically create a proxy for each bean containing `@EventHandler` annotated methods to turn them into a full blown event listener.
# `TransactionalAnnotationEventListenerBeanPostProcessor` is a specialized version that provides support for transactional processing to your event handlers. This is useful if you are updating database tables using incoming events.

Configuring the annotation bean post processor is as easy as adding the following XML to your application context:
{{{
<bean class="nl.gridshore.cqrs4j.eventhandler.annotation.postprocessor.TransactionalAnnotationEventListenerBeanPostProcessor">
    <property name="transactionManager" ref="transactionManager"/>
</bean>
}}}

=Creating an annotated event handler=
Creating an annotated event listener is pretty easy. You don't need to extend any special classes. All you need to do is annotate any methods that you want called when en event comes in with the `@EventHandler` annotation.

There are, however, a few rules for these methods:
* The method must accept 1 parameter
* The parameter must be a subtype of {`DomainEvent`} 
* Return values are allowed, but are ignored by dispatchers 
* Exceptions are highly discouraged, and are likely to be caught and ignored by the dispatchers

Once the annotation bean post processor is defined in the spring application context, all you need to to is add the bean definitions of your annotated event listeners to the context. That's it.

Examples of valid event handler signatures:
{{{
public void onSomeEvent(SomeEvent event)
public Object onSomeEvent(SomeEvent event)
}}}

Good, but highly discouraged:
{{{
public void onSomeEvent(SomeEvent event) throws SomeCheckedException
}}}

Wrong:
{{{
public void onSomeEvent(SomeEvent event, SomeOtherInformation info)
public void onSomeEvent(DoesNotExtendDomainEvent event)
}}}

= Adding transaction support =
_cqrs4j_ provides out-of-the-box support for Spring style transaction management. If you have configured the `TransactionalAnnotationEventListenerBeanPostProcessor` with a transaction manager, your event handler methods will be called transactionally if they (or the class they are defined in) contains Spring's `@Transactional` annotation.

By default, _cqrs4j_ will process multiple events in a single transaction, provided that they are available at the time any previous events are done processing. This means that a transaction will never stall waiting for more incoming events.

You can configure the maximum number of events that may be handled in a single transaction using the `commitThreshold` option on the `@EventHandler` annotation. Setting this commit threshold will force the _cqrs4j_ to commit a transaction as soon as the `commitThreshold` is reached.

The basic rule is as follows: an event will never be handled in a transaction that contains with more events than defined by `commitThreshold`. Setting this value to 1 will guarantee that the event is handled in its own (dedicated) transaction.

Allowing more events to be handled within the same transaction could improve performance. The default value of `commitThreshold` is 50.